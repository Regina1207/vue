1、请描述一下 cookies sessionStorage和localstorage区别
    相同点：都存储在客户端
    不同点：1.存储大小
            cookie数据大小不能超过4k。
            sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
        2.有效时间
            localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
            sessionStorage  数据在当前浏览器窗口关闭后自动删除。
            cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭

2、什么是ajax，如何使用ajax？
    ajax就是一个异步请求对象
    优点：1、不能刷新网页的情况下，可以局部的自动刷新某个区域
          2、提高网页性能，提高用户体验度
    缺点：1、破坏了浏览器的历史记录
          2、破坏了JS的执行机制
    第一步创建异步请求对象
    第二步建立连接
    第三步发送请求
    第四步注册监听函数

3、px和em的区别？
    1、共同点：长度单位
    2、不同点：px是固定的，em不是固定的

4、jquery中为什么可以实现链式调用？
    jquery中的选择器每次选择完成之后都会返回一个选择器对象

5、window.onload和$(document).ready的区别是什么？
    window.onload是等DOM、CSS、JS、图片所有的资源全部加载完成之后再去执行
    $(document).ready是等DOM结构，也就是页面布局完成之后即可使用JQ操作

6、JS中this和$(this)的区别？
    JS中的this是DOM对象本身，是当前DOM对象的上下文
    $(this)是JQ中的DOM元素上下文，而且返回伪数组，即是对象，也有数组的特点

7、为什么vuex可以解决组件深层次数据传递问题？
    答案：
        因为每个组件都有一个$store对象，当前$store对象指向的实例是Vuex中的Store()
        Store():全部的vuex属性、方法、数据等等都存在于其内部

8、什么时候必须通过name属性进行跳转？
    使用编程式导航时，进行传递params参数时，通过name进行跳转，否则无效

9、箭头函数有什么特点？
    1、简化了普通函数写法
    2、没有arguemnts对象
    3、没有this，借用的是当前环境的上下文（直接父级的this）
    4、不能被实例化，不能作为构造函数
    5、如果没有参数不能省略小括号，如果有一个参数可以省略小括号，多个参数不能省略小括号
    6、箭头函数中如果只有一行函数体，则省略大括号和return
    7、没有prototype对象

10、vue-router有哪几种导航钩子?
    1、全局导航钩子：router.beforeEach(to,from,next)作用：跳转前进行判断拦截
    2、组件内的钩子
    3、单独路由独享组件

11、一个URL输入到地址栏到显示页面都经历里哪些过程？
    1、查看本地（浏览器）是否有缓存，有缓存则直接从本地获取页面，没有向后台发送请求
    2、DNS解析（查询）解析你自己本机的API
    3、TCP三次握手，建立连接
    4、传输数据
    5、浏览器解析并渲染页面
    6、TCP四次挥手，断开连接

12、typeof判断 null 为什么返回的是"object"?
    1、计算机存储的任何数据类型都以二进制的形式存储进去，
    2、所有的引用数据类型的值为： []:000111  {}:000x12  Data():000f34
    3、null虽然是基本数据类型，但是存值的时候以000开头

    typeof判断数据类型时，000开头的都返回'object'

13、跨域问题如何解决
    1、 通过jsonp跨域
    2、 postMessage跨域
    3、 cors
    4、 nginx反向代理服务器
    5、 nodejs中间件代理跨域： vue框架的跨域webpack.config.js部分配置
    6、 WebSocket协议跨域

14、Promise()有什么特点？
    Promise是一个微任务，Promise函数体里面是同步执行，Promise.then()真正的
            微任务，异步执行（去任务队列排队执行）

            1、三个状态：pending（准备）、成功、失败
            2、状态不可逆 ，要么从pending到成功，要么从pending到失败
            3、then是成功的回调函数，成功后数据传递到then里面
            4、catch是失败的回调函数，将错误信息全部传递到catch里面
            5、Promise对象接收一个解析器【excutor】，本质是回调函数，回调函数
               接收两个参数，都为回调函数，一个是成功【resolved】的回调
               一个是失败【rejected】的回调
            6、每个then或者catch中都返回一个新的Promise对象，所以可以链式调用
               把地狱回调变成了链式调用，没有完全解决地狱回调（死亡回调）
            7、.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。
            8、Promise方法链通过return传值，没有return就只是相互独立的任务而已

15、get和post的区别？
    1、get是不安全的，数据被放在请求的URL中，post实在请求体里
    2、get传输的数据量小，因为手URL长度的限制
    3、get执行效率比post方法好，get是form提交的默认方法 

16、请说出你关于闭包函数的理解
    闭包函数通常情况下是指函数里面再一次的嵌套另外的一个函数这种形式，而处于函数内部的函数可以获取外部函数的变量的值

17、vue中组件分为三类、组件类型：
    1、类组件：每个组件都有完整的功能，如：生命周期、data函数、实例【this】，有自己完整的功能
    2、函数式组件：
        概念：
            就是一个普通函数，大大降低了一个组件渲染消耗过程，主要负责写UI和CSS
            数据都是从父组件传递过来的，目前vue的版本直接可以解析props，不用声明
            props属性
        如何让一个组件变成函数式组件？
            设置一个functional:true,默认值为true，属性即可
        场景：展示型页面
        1、无状态：自己组件内部不管理数据，也不操作数据
        2、没有实例，没有this，没有生命周期，没有数据
        3、只会解析一个props属性，目前自动解析
        优点：
            消耗非常少，只是执行了一个普通函数，渲染过程减少
    3、递归组件
        概念：数据不确定嵌套多少层，使用vue中递归组件自动去渲染，如果有多少层数据
            则展示多层结构【自动】，当前组件调用自身，根据name组件名进行调用
        场景：左侧嵌套导航菜单，权限配置
            父组件内引入递归子组件，通过绑定自定义属性传递数据（父传子）
            子组件内接收，渲染，判断数据解构内是否有嵌套数据，如果有，则调用自身组件（通过name名调用）
            如果没有则停止调用
        注意：递归组件必须要有结束条件

18、Vue中双向数据绑定是如何实现的？
    注意：vue不兼容IE8及以下的浏览器（ES3中根本就没有这个Object.defineProperty()方法）
        Object.defineProperty()在IE8及以下的浏览器不能shim(无法优雅降级 )
    原理：
        数据劫持，通过ES5中的Object.defineProperty()监听数据并且劫持数据
        然后具体通过get、set把vue组件中的data数据拦截修改并转换成getter、setter
        方法进行监听修改数据（响应式数据），当属性被访问、修改时，通过watcher桥梁（信息转换站）
        通知组件进行变化，组件调用render进行更新页面

19、v-modal的使用。
答：v-model用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：
    v-bind绑定一个value属性；
    v-on指令给当前元素绑定input事件。

20、如何让CSS只在当前组件中起作用？
    在组件中的style前面加上scoped

21、visibility: hidden和display: none 有什么不同？
    visibility: hidden----将元素隐藏，但是在网页中该占的位置还是占着。
    display: none----将元素的显示设为无，即在网页中不占任何的位置。

22、JS的执行过程？
    1、JS在栈里面执行，JS在主线程从上到下执行
    2、主线程优先执行同步代码
    3、任务队列里面存入异步代码
    4、主线程执行完所有的同步代码，才去检查任务队列中是否有

23、xml和json的区别？
    1，xml是重量级的，json是轻量级的。
    2，xml在传输过程中比较占带宽，json占带宽少，易于压缩。
    3，xml和json都用在项目交互下，xml多用于做配置文件，json用于数据交互。
    4，json可用jackson，gson等方法解析，xml可用dom，sax，demo4j等方式解析。

24、强缓存和协商缓存的区别？
    两者的共同点是：都是从客户端缓存中读取资源
    1.强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码;
    2.协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，
        如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；

25、声明式导航和编程式导航的区别？
    共同点:都能进行导航，都可以触发路由，实现组件切换
    区别：
        写法不一样，声明式导航是写在组件的template中，通过router-link来触发，
        编程式导航写在js函数中，通过this.$router.push(xxx)来触发路径

26、vue组件中data为什么是函数，而不是对象？
    vue组件中data值不能为对象，因为对象是引用数据类型，组件可能会被多个实例同时引用
    如果组件中的data值为对象时，将导致多个组件共享一个对象，其中一个组件改变data属性值，
    其他将会受影响

28、请问v-if和v-show，你经常使用哪个？使用哪个更好一些？为什么？
    v-show：加载了文档流，存在于document文档里面，控制css，display:none/block;
    v-if：算法，逻辑算法
    经常使用v-show即可（简单）

29、路由跳转原理：
    1、调用了vue-router里面的this.$router.push()方法
    2、第一步触发了浏览器中History对象中的push()方法  
    3、第二步触发了History对象中的transitionTo()方法，检测路由变化的函数
    4、第三步触发了History对象中的updateRoute()方法，更新路由,路径已经跳转了 
    5、Vue.$router = updateRoute()
    6、Vue.render()   render()渲染、更新页面的

30、hash和history及abstract区别：
    history：跳转路径时，页面每次需要和服务端进行交互，服务端返回最新的
             页面给前端，前端展示
    hash：每次跳转，页面不和服务端进行交互 （真正的锚点跳转）
    abstract：用于node环境中的路由跳转，浏览器无法使用

31、分别简述computed和watch的使用场景？
    computed:组件中的计算属性，有缓存值
    watch：组件内部的监听属性，可以监听到props、data、路由跳转中数据
    deep:true           深度监听        不经常使用
    immediate:true      立即开启监听
    如果给监听的变量添加''，就是精确监听（值监听当前的变量）

32、ES6中的新语法有哪些？
    let:
        概念：命名变量的
        1、一旦声明，就不能再进行修改了 
        2、暂时性死区
        3、不存在变量提升
        4、独立的作用域 (减少闭包的使用)

    const:
        概念：命名常量的
        1、一旦声明，就不能再进行修改了
        2、暂时性死区
        3、不存在变量提升
        4、独立的作用域 (减少闭包的使用)

    ...:扩展运算符（展开运算符）
        1、解构一层数据解构
        2、只能用在引用数据类型中
        3、在函数中使用为参数时，只能是最后一个参数，用于收集额外的实参（通过一个集合进行收集）

33、对ES6中的class有什么看法？
    1、ES6中的class只是function的语法糖
    2、class类中的构造器【contructor】指向的是当前class类 --》【class Person】
    3、通过contructor函数接收参数
    4、子类通过extends配合super进行继承

34、原型链的查找机制？
    首先先查找自身对象是否有，如果有就返回，没有就通过__proto__去原型查找，如果有就返回，
    如果没有就沿着原型链继续查找，直到Object.proyotype原型，查到就返回，查不到就返回undefined

35、事件流的过程？
    捕获阶段：当某个元素触发事件的时候，顶层对象window就会发出事件流，由根节点流向目标对象，
        所经过的各个节点的事件都不触发
    目标阶段：事件流流向目标对象的时候，目标对象的事件触发，准备事件冒泡阶段
    冒泡阶段：由目标节点流向根节点，所经过的各个节点，如果有事件，执行该事件，这样就形成了一个闭环

36、http和https的区别？
    共同点：1.都是建立在TCP通信协议之上
            2.传输数据
    不同点：http:超文本传输协议
            特点：明码传输，
            优点：性能好，消耗少
            缺点：安全性差，容易被监听，被伪装，被篡改
        https：超文本传输安全协议
            特点：加密传输
            优点：安全，解决了http存在的问题
            缺点：消耗大，浪费资源，费时，安全证书需要花钱，浏览器的缓存不如http的好
37、什么是同源策略？
    只要协议、域名、子域名、端口号中相同，如果有一个不一样，也就是违反了同源策略，
    就说明你不是本地网站，则会产生跨域

38、浏览器的垃圾回收机制？
    1、标记清除：贴标签
        标记：进入环境（执行环境），GC进行标记，使用完了，离开环境，被再次标记
        清除：把离开环境时被标记变量，通过GC主动的回收清除
    2、引用计数清除：计时间
        1.命名变量时，默认的起始数据为1
        2.当被赋值引用时，数量加1
        3.释放引用时，数量减1
        4.当变量的数为0时，则被认为是垃圾，GC会主动回收它

39、JS的模块化有哪些，有什么优点？
    commonJS(主要在node环境中运行，一切都是同步运行，按需加载，提高性能)、AMD、CMD、ES6 Module
    优点：1.集中管理
        2.便于维护，便于调试，版本迭代
        3.JS文件之间可以互相交互
        4.极大的避免了环境污染
        5.对代码测试友好
        6.可以多人协作开发，互补影响
        7.模块之间可以自由组合
        8.偏向于工程化
        9.减少http请求
    缺点：解析JS时，执行链比较长，浪费性能

40、什么是函数的节流和防抖？
    防抖函数：将多次触发变成最后一次触发；
    节流函数：将多次执行变成每隔一个时间节点去执行的函数

41、call、apply区别？
    相同点：都是重定向this指针的方法。
    不同点：call和apply的第二个参数不相同，call是若干个参数的列表。apply是一个数组

42、什么是值穿透？
    .then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透
    Promise方法链通过return传值，没有return就只是相互独立的任务而已

43、Vue之性能优化
    1、代码模块化
    2、for循环设置key值
    3、Vue路由设置成懒加载
    4、更加理解Vue的生命周期
    5、可以使用keep-alive
    6、按需引入

44、link和import的区别？
    两者都是外部引用CSS的方式
    link引用CSS时，在页面载入时同时加载；@import需要页面完全载入以后加载。

45、vuex的特点？
    1.单向数据流
    2.数据共享
    3.集中管理数据
    4.易于后期维护
    5.易于测试
    6.状态管理更简单
    7.解决了复杂（深层嵌套的组件）的组件之间的通信

     缺点：
        1.增加了开发成本（写的代码多了）

46、构造函数的执行过程？
    创建一个空对象
    new关键字改变this执行
    定义属性和行为
    返回

47、vue中的指令举例五个，并说出他的作用是什么？
    1、v-bind:用于给template模板元素绑定属性
    2、v-on：用于绑定事件
    3、v-cloak:原理：display:none
        解决花括号闪烁问题
    4、v-show：用于显示或者隐藏元素的指令
    5、v-slot：插槽指令

48、 要想操作真实DOM元素？
    1、在mounted挂载中生命周期
    2、nextTick()函数中操作
    3、ref

49、如果数据变化了，页面不更新怎么办？
    1、看数据是否是响应式的，如果不是通过Vue.set()【全局】   this.$set()【组件】变成响应式数据
    2、强制更新试图  this.$forceUpdate()：强制调用render函数（缺点：耗性能）

50、vue组件有缓存怎么办？
    this.$destroy()：销毁缓存，组件还在，让当前组件进入初始化状态（不常用）

